// DE2 -- 115
module elevator_module
  #(parameter N = 5, //Number of floors
    parameter board_freq = 50000, //Freq of FPGA (50 MGhz)
    parameter module_freq = 1, //Freq of Module (1 Hz)
    parameter door_open_time = 10 
    )
( 
    input [N:1] request_up_button, //Button up outside the elevator// 1- 5: SW17 - SW 13
    input [N:1] request_down_button, //Button down outside the elevator: 1-5: SW12 - SW 8
    input close_button,              //Button Close the Door inside the elevavtor   SW1
    input open_button,               //Button Open the Door inside the elevator SW2
    input [N:1] input_floor_button,   //Choose Floor inside the elevator// 1-5:    SW7 - SW3
    input board_clk,                  //Freq of FPGA    

    output reg door_led,    // 0 = close, 1 = open  // LED G7
    output reg go_up_led,   // =1 when up_direction = 1;    // LEDR1
    output reg go_down_led, // =1 when down_direction = 1;  // LEDR0
    output reg [N:1] led_up,    //Led outside the elevator each floor// 1-5: LEDR17 - LEDR13
    output reg [N:1] led_down, // Led outside the elevator each floor// 1-5: LEDR12- LEDR8
    
    //Led Current Floor // HEX 7
    output seg_a,
    output seg_b,
    output seg_c,
    output seg_d,
    output seg_e,
    output seg_f,
    output seg_g
);
    localparam  WAIT  = 2'b00,
                UP    = 2'b01,
                DOWN  = 2'b10,
                OPEN  = 2'b11;
    

    // Variable for Loop
    integer i;


    wire clk;               //Clock of module

    reg request_floor[N:1];             //For 5 floors, which floor has request will be assigned to 1
    reg [2:0] current_floor; //Current Floor of Elevator
    reg [2:0]next_floor; 
    reg door;                          //1 = open, 0 = close
    reg current_state;
    reg open_request;             // Open Door when elevator reaches the goal
	reg next_state ;              //State and next_state of
    reg request_up_from_current;    //Request up from current Floor 
    reg request_down_from_current;  //Request down from current Floor
    reg request_up_from_higher;     //Request up from Higher Floor
    reg request_down_from_higher;   //Request down from higher Floor
    reg request_up_from_lower;      //Request up from lower Floor
    reg request_down_from_lower;    //Request down from lower Floor
    reg [5:1]input_floor_reg;            //Variable for Saving the goal floor        
    reg [5:1]request_down_reg;           //Variable for Saving the goal floor        
    reg [5:1]request_up_reg;            //Variable for Saving the goal floor        
    reg door_count;
    reg up_direction;               //Elevetor is moving up
    reg down_direction;             //Elevetor is moving down
    initial 
    begin
        door_led = 0;
        go_up_led = 0;
        go_down_led = 0;
        led_up [N:1] = 5'b00000;
        led_down [N:1] = 5'b00000;
        current_floor = 1;
        door_count = door_open_time;         
        request_up_from_current = 0;
        request_down_from_current = 0;
        request_up_from_higher = 0;
        request_down_from_higher = 0;
        request_up_from_lower = 0;
        request_down_from_lower = 0;
        input_floor_reg = 5'b00000;
        request_down_reg = 5'b000000;
        request_up_reg = 5'b000000;
        current_state = WAIT;
        
    end
    always @(posedge clk)
    begin
        current_state <= next_state;
    end
    /**

    always @(posedge request_up_button ) //Save the Goal floor
    begin
        for (i = 1; i < N + 1; i = i+ 1)
        begin
            input_floor_reg[i] <= input_floor_button[i];
        end
    end

    always @(posedge request_up_button ) //Save the up request
    begin
        for (i = 1; i< N + 1; i = i + 1)
        begin
            request_up_reg[i] <= request_up_button[i];
        end
    end

    always @(posedge request_down_button)
    begin
        for (i = 1; i< N + 1; i = i + 1)
        begin
            request_down_reg[i] <= request_down_button[i];
        end
    end
    **/

    always @(posedge clk) 
    begin
    for (i = 1; i < N + 1; i = i + 1)
    begin
        if (input_floor_button[i] == 1)  // Khi nhấn nút chọn tầng
            input_floor_reg[i] <= 1;
        else if (input_floor_button[i] == 0 || current_floor == i )     // Reset khi thang máy đến tầng đó
            input_floor_reg[i] <= 0;
    end
    end

    always @(posedge clk) 
    begin
    for (i = 1; i < N + 1; i = i + 1)
    begin
        if (request_up_button[i] == 1)   // Khi nhấn nút yêu cầu đi lên
            request_up_reg[i] <= 1;
        else if (request_up_button[i] == 0 || current_floor == i )     // Reset khi thang máy đến tầng đó
            request_up_reg[i] <= 0;
    end
    end

    always @(posedge clk)
    begin
    for (i = 1; i < N + 1; i = i + 1)
    begin
        if (request_down_button[i] == 1) // Khi nhấn nút yêu cầu đi xuống
            request_down_reg[i] <= 1;
        else if (request_down_button[i] == 0 || current_floor == i)     // Reset khi thang máy đến tầng đó
            request_down_reg[i] <= 0;
    end
    end

    //Handle reuqest
    always @(*)
    begin //: Handel Request;
        request_up_from_current = 0;
        request_down_from_current = 0;
        request_up_from_higher = 0;
        request_down_from_higher = 0;
        request_up_from_lower = 0;
        request_down_from_lower = 0;
        
        for (i = 1; i < N + 1; i = i+ 1)
        begin 
            if (request_up_reg[i] || request_down_reg[i] || input_floor_reg[i]) request_floor[i] = 1; 
            else request_floor[i] = 0;
        end

        // Handle current floor request
        if (request_floor[current_floor])
        begin
            if (input_floor_reg[current_floor]) // Elevator reaches the requested floor
            begin
                // input_floor_reg[current_floor] = 0;     
                // request_up_reg[current_floor] = 0;
                // request_down_reg[current_floor] = 0;
                open_request = 1; 
            end
            else
            begin
                open_request = 0;
                for (i = 1; i <= N; i = i + 1)
                begin
                    if (input_floor_reg[i] && i > current_floor)
                        request_up_from_current = 1;
                    else
                        request_up_from_current = 0;

                    if (input_floor_reg[i] && i < current_floor)
                        request_down_from_current = 1;
                    else
                        request_down_from_current = 0;
                end
            end
        end
        else 
        begin
            // Handle requests from higher floors
            for (i = 1; i <= N; i = i + 1)
            begin
                if (i > current_floor && request_floor[i])
                begin
                    if (input_floor_reg[i] || request_up_reg[i])
                        request_up_from_higher = 1;
                    else
                        request_up_from_higher = 0;

                    if (request_down_reg[i])
                        request_down_from_higher = 1;
                    else
                        request_down_from_higher = 0;
                end
                // Handle requests from lower floors
                if (i < current_floor && request_floor[i])
                begin
                    if (input_floor_reg[i] || request_down_reg[i])
                        request_down_from_lower = 1;
                    else
                        request_down_from_lower = 0;

                    if (request_up_reg[i])
                        request_up_from_lower = 1;
                    else
                        request_up_from_lower = 0;
                end
            end
        end
    end

    always @(posedge clk)
    begin // Identify the next State of the elevator for each request
        if (current_state == WAIT)
        begin
            if (open_button == 1 || open_request == 1)
            begin
                next_state <= OPEN;
            end
            else if (close_button == 1)
            begin
                next_state <= WAIT;
            end
            else if (request_up_from_higher || request_up_from_current || request_down_from_higher)
            begin
                next_state <= UP;
            end
            else if (request_down_from_current || request_down_from_lower || request_up_from_lower)
            begin
                next_state <= DOWN;
            end
            else next_state <= WAIT;
        end
        else if (current_state == OPEN)
        begin
            if (open_button == 1)
            begin
                door_count <= door_open_time;
                next_state <= OPEN;
            end
            else if (close_button == 1)
            begin
                door_count <= door_open_time;
                next_state <= WAIT;
            end
            else if (request_up_from_current || request_down_from_current || request_up_from_lower || request_down_from_lower || 
            request_up_from_higher || request_down_from_higher)
            begin
                door_count <= door_open_time;
                next_state <= WAIT;
            end
            else 
            begin
                door_count = door_count - 1;
                if (door_count == 0)
                begin
                    door_count <= door_open_time;
                    next_state <= WAIT;
                end
                else next_state <= OPEN;
            end
        end
        else if (current_state == UP)
        begin
            if (open_button || close_button)
            begin
                next_state <= UP;
            end
            else if (!(request_up_from_current || request_up_from_higher || request_down_from_higher)) //When have no request go up, stop and Open door for 10s
            begin
                next_state <= OPEN;
            end
            else next_state <= UP;                                   //OThers case elevator continue go up
        end
        if (current_state == DOWN)
        begin
            if(open_button || close_button)
            begin
                next_state <= DOWN;
            end
            else if(!(request_down_from_current || request_down_from_lower|| request_up_from_lower)) //When have no request go down, stop and Open door for 10s 
            begin
                next_state <= OPEN;
            end
            else next_state <= DOWN;                                 //Others case elevator continue go down
        end


    end
    
    /** Each State of Elevator**/
    always @(posedge clk)
    begin
        
        case (current_state)
        OPEN:
        begin
            up_direction <= 0;
            down_direction <= 0;
            door <= 1;
        end
        WAIT:
        begin
            up_direction <= 0;
            down_direction <= 0;
            door <= 0;
        end
        UP:
        begin
            door <= 1;
            up_direction <= 1;
            down_direction <= 0;
            next_floor <= current_floor + 1;
            current_floor <= next_floor;
        end
        DOWN:
        begin
            door <= 1;
            up_direction <= 0;
            down_direction <= 1;
            next_floor <= current_floor - 1;
            current_floor <= next_floor;
        end
        endcase
        if (door == 1)
        begin
            door_led <= 1;
        end
        else door <= 0;
    
    end
    always @(*)
    begin //output;
        if (up_direction && !down_direction)
        begin
            go_up_led = 1;
        end
        else if (down_direction && !up_direction)
        begin
            go_down_led = 1;
        end
        else 
        begin
            go_down_led = 0;
            go_up_led = 0;
        end
        led_up = request_up_reg;
        led_down = request_down_reg;
        
    end

    clk_gen_module #(board_freq, module_freq) gen_clk (
        .pulse(board_clk),
        .clk(clk));

    // Seven-segment display for current floor
    seven_segment floor_display (
        .input_num({1'b0,current_floor}),
        .a_segment(seg_a),
        .b_segment(seg_b),
        .c_segment(seg_c),
        .d_segment(seg_d),
        .e_segment(seg_e),
        .f_segment(seg_f),
        .g_segment(seg_g));
endmodule